// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO2

package com.google.protobuf.descriptor

import scala.collection.JavaConverters._

/** @param ctype
  *   The ctype option instructs the C++ code generator to use a different
  *   representation of the field than it normally would.  See the specific
  *   options below.  This option is not yet implemented in the open source
  *   release -- sorry, we'll try to include it in a future version!
  * @param packed
  *   The packed option can be enabled for repeated primitive fields to enable
  *   a more efficient representation on the wire. Rather than repeatedly
  *   writing the tag and type for each element, the entire array is encoded as
  *   a single length-delimited blob. In proto3, only explicit setting it to
  *   false will avoid using packed encoding.
  * @param jstype
  *   The jstype option determines the JavaScript type used for values of the
  *   field.  The option is permitted only for 64 bit integral and fixed types
  *   (int64, uint64, sint64, fixed64, sfixed64).  By default these types are
  *   represented as JavaScript strings.  This avoids loss of precision that can
  *   happen when a large value is converted to a floating point JavaScript
  *   numbers.  Specifying JS_NUMBER for the jstype causes the generated
  *   JavaScript code to use the JavaScript "number" type instead of strings.
  *   This option is an enum to permit additional types to be added,
  *   e.g. goog.math.Integer.
  * @param lazy
  *   Should this field be parsed lazily?  Lazy applies only to message-type
  *   fields.  It means that when the outer message is initially parsed, the
  *   inner message's contents will not be parsed but instead stored in encoded
  *   form.  The inner message will actually be parsed when it is first accessed.
  *  
  *   This is only a hint.  Implementations are free to choose whether to use
  *   eager or lazy parsing regardless of the value of this option.  However,
  *   setting this option true suggests that the protocol author believes that
  *   using lazy parsing on this field is worth the additional bookkeeping
  *   overhead typically needed to implement it.
  *  
  *   This option does not affect the public interface of any generated code;
  *   all method signatures remain the same.  Furthermore, thread-safety of the
  *   interface is not affected by this option; const methods remain safe to
  *   call from multiple threads concurrently, while non-const methods continue
  *   to require exclusive access.
  *  
  *  
  *   Note that implementations may choose not to check required fields within
  *   a lazy sub-message.  That is, calling IsInitialized() on the outher message
  *   may return true even if the inner message has missing required fields.
  *   This is necessary because otherwise the inner message would have to be
  *   parsed in order to perform the check, defeating the purpose of lazy
  *   parsing.  An implementation which chooses not to check required fields
  *   must be consistent about it.  That is, for any particular sub-message, the
  *   implementation must either *always* check its required fields, or *never*
  *   check its required fields, regardless of whether or not the message has
  *   been parsed.
  * @param deprecated
  *   Is this field deprecated?
  *   Depending on the target platform, this can emit Deprecated annotations
  *   for accessors, or it will be completely ignored; in the very least, this
  *   is a formalization for deprecating fields.
  * @param weak
  *   For Google-internal migration only. Do not use.
  * @param uninterpretedOption
  *   The parser stores options it doesn't recognize here. See above.
  */
@SerialVersionUID(0L)
final case class FieldOptions(
    ctype: scala.Option[com.google.protobuf.descriptor.FieldOptions.CType] = None,
    packed: scala.Option[Boolean] = None,
    jstype: scala.Option[com.google.protobuf.descriptor.FieldOptions.JSType] = None,
    `lazy`: scala.Option[Boolean] = None,
    deprecated: scala.Option[Boolean] = None,
    weak: scala.Option[Boolean] = None,
    uninterpretedOption: scala.collection.Seq[com.google.protobuf.descriptor.UninterpretedOption] = Nil
    ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[FieldOptions] with com.trueaccord.lenses.Updatable[FieldOptions] {
    @transient
    private[this] var __serializedSizeCachedValue: Int = 0
    private[this] def __computeSerializedValue(): Int = {
      var __size = 0
      if (ctype.isDefined) { __size += _root_.com.google.protobuf.CodedOutputStream.computeEnumSize(1, ctype.get.value) }
      if (packed.isDefined) { __size += _root_.com.google.protobuf.CodedOutputStream.computeBoolSize(2, packed.get) }
      if (jstype.isDefined) { __size += _root_.com.google.protobuf.CodedOutputStream.computeEnumSize(6, jstype.get.value) }
      if (`lazy`.isDefined) { __size += _root_.com.google.protobuf.CodedOutputStream.computeBoolSize(5, `lazy`.get) }
      if (deprecated.isDefined) { __size += _root_.com.google.protobuf.CodedOutputStream.computeBoolSize(3, deprecated.get) }
      if (weak.isDefined) { __size += _root_.com.google.protobuf.CodedOutputStream.computeBoolSize(10, weak.get) }
      uninterpretedOption.foreach(uninterpretedOption => __size += 2 + _root_.com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(uninterpretedOption.serializedSize) + uninterpretedOption.serializedSize)
      __size
    }
    final override def serializedSize: Int = {
      var read = __serializedSizeCachedValue
      if (read == 0) {
        read = __computeSerializedValue()
        __serializedSizeCachedValue = read
      }
      read
    }
    def writeTo(`_output__`: _root_.com.google.protobuf.CodedOutputStream): Unit = {
      ctype.foreach { __v =>
        _output__.writeEnum(1, __v.value)
      };
      packed.foreach { __v =>
        _output__.writeBool(2, __v)
      };
      deprecated.foreach { __v =>
        _output__.writeBool(3, __v)
      };
      `lazy`.foreach { __v =>
        _output__.writeBool(5, __v)
      };
      jstype.foreach { __v =>
        _output__.writeEnum(6, __v.value)
      };
      weak.foreach { __v =>
        _output__.writeBool(10, __v)
      };
      uninterpretedOption.foreach { __v =>
        _output__.writeTag(999, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
    }
    def mergeFrom(`_input__`: _root_.com.google.protobuf.CodedInputStream): com.google.protobuf.descriptor.FieldOptions = {
      var __ctype = this.ctype
      var __packed = this.packed
      var __jstype = this.jstype
      var __lazy = this.`lazy`
      var __deprecated = this.deprecated
      var __weak = this.weak
      val __uninterpretedOption = (scala.collection.immutable.Vector.newBuilder[com.google.protobuf.descriptor.UninterpretedOption] ++= this.uninterpretedOption)
      var _done__ = false
      while (!_done__) {
        val _tag__ = _input__.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 8 =>
            __ctype = Some(com.google.protobuf.descriptor.FieldOptions.CType.fromValue(_input__.readEnum()))
          case 16 =>
            __packed = Some(_input__.readBool())
          case 48 =>
            __jstype = Some(com.google.protobuf.descriptor.FieldOptions.JSType.fromValue(_input__.readEnum()))
          case 40 =>
            __lazy = Some(_input__.readBool())
          case 24 =>
            __deprecated = Some(_input__.readBool())
          case 80 =>
            __weak = Some(_input__.readBool())
          case 7994 =>
            __uninterpretedOption += _root_.com.trueaccord.scalapb.LiteParser.readMessage(_input__, com.google.protobuf.descriptor.UninterpretedOption.defaultInstance)
          case tag => _input__.skipField(tag)
        }
      }
      com.google.protobuf.descriptor.FieldOptions(
          ctype = __ctype,
          packed = __packed,
          jstype = __jstype,
          `lazy` = __lazy,
          deprecated = __deprecated,
          weak = __weak,
          uninterpretedOption = __uninterpretedOption.result()
      )
    }
    def getCtype: com.google.protobuf.descriptor.FieldOptions.CType = ctype.getOrElse(com.google.protobuf.descriptor.FieldOptions.CType.STRING)
    def clearCtype: FieldOptions = copy(ctype = None)
    def withCtype(__v: com.google.protobuf.descriptor.FieldOptions.CType): FieldOptions = copy(ctype = Some(__v))
    def getPacked: Boolean = packed.getOrElse(false)
    def clearPacked: FieldOptions = copy(packed = None)
    def withPacked(__v: Boolean): FieldOptions = copy(packed = Some(__v))
    def getJstype: com.google.protobuf.descriptor.FieldOptions.JSType = jstype.getOrElse(com.google.protobuf.descriptor.FieldOptions.JSType.JS_NORMAL)
    def clearJstype: FieldOptions = copy(jstype = None)
    def withJstype(__v: com.google.protobuf.descriptor.FieldOptions.JSType): FieldOptions = copy(jstype = Some(__v))
    def getLazy: Boolean = `lazy`.getOrElse(false)
    def clearLazy: FieldOptions = copy(`lazy` = None)
    def withLazy(__v: Boolean): FieldOptions = copy(`lazy` = Some(__v))
    def getDeprecated: Boolean = deprecated.getOrElse(false)
    def clearDeprecated: FieldOptions = copy(deprecated = None)
    def withDeprecated(__v: Boolean): FieldOptions = copy(deprecated = Some(__v))
    def getWeak: Boolean = weak.getOrElse(false)
    def clearWeak: FieldOptions = copy(weak = None)
    def withWeak(__v: Boolean): FieldOptions = copy(weak = Some(__v))
    def clearUninterpretedOption = copy(uninterpretedOption = scala.collection.Seq.empty)
    def addUninterpretedOption(__vs: com.google.protobuf.descriptor.UninterpretedOption*): FieldOptions = addAllUninterpretedOption(__vs)
    def addAllUninterpretedOption(__vs: TraversableOnce[com.google.protobuf.descriptor.UninterpretedOption]): FieldOptions = copy(uninterpretedOption = uninterpretedOption ++ __vs)
    def withUninterpretedOption(__v: scala.collection.Seq[com.google.protobuf.descriptor.UninterpretedOption]): FieldOptions = copy(uninterpretedOption = __v)
    def getField(__field: _root_.com.google.protobuf.Descriptors.FieldDescriptor): scala.Any = {
      __field.getNumber match {
        case 1 => ctype.map(_.javaValueDescriptor).orNull
        case 2 => packed.orNull
        case 6 => jstype.map(_.javaValueDescriptor).orNull
        case 5 => `lazy`.orNull
        case 3 => deprecated.orNull
        case 10 => weak.orNull
        case 999 => uninterpretedOption
      }
    }
    override def toString: String = _root_.com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
    def companion = com.google.protobuf.descriptor.FieldOptions
}

object FieldOptions extends com.trueaccord.scalapb.GeneratedMessageCompanion[com.google.protobuf.descriptor.FieldOptions] with com.trueaccord.scalapb.JavaProtoSupport[com.google.protobuf.descriptor.FieldOptions, com.google.protobuf.DescriptorProtos.FieldOptions] {
  implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[com.google.protobuf.descriptor.FieldOptions] with com.trueaccord.scalapb.JavaProtoSupport[com.google.protobuf.descriptor.FieldOptions, com.google.protobuf.DescriptorProtos.FieldOptions] = this
  def toJavaProto(scalaPbSource: com.google.protobuf.descriptor.FieldOptions): com.google.protobuf.DescriptorProtos.FieldOptions = {
    val javaPbOut = com.google.protobuf.DescriptorProtos.FieldOptions.newBuilder
    scalaPbSource.ctype.map(com.google.protobuf.descriptor.FieldOptions.CType.toJavaValue(_)).foreach(javaPbOut.setCtype)
    scalaPbSource.packed.foreach(javaPbOut.setPacked)
    scalaPbSource.jstype.map(com.google.protobuf.descriptor.FieldOptions.JSType.toJavaValue(_)).foreach(javaPbOut.setJstype)
    scalaPbSource.`lazy`.foreach(javaPbOut.setLazy)
    scalaPbSource.deprecated.foreach(javaPbOut.setDeprecated)
    scalaPbSource.weak.foreach(javaPbOut.setWeak)
    javaPbOut.addAllUninterpretedOption(scalaPbSource.uninterpretedOption.map(com.google.protobuf.descriptor.UninterpretedOption.toJavaProto(_)).asJava)
    javaPbOut.build
  }
  def fromJavaProto(javaPbSource: com.google.protobuf.DescriptorProtos.FieldOptions): com.google.protobuf.descriptor.FieldOptions = com.google.protobuf.descriptor.FieldOptions(
    ctype = if (javaPbSource.hasCtype) Some(com.google.protobuf.descriptor.FieldOptions.CType.fromJavaValue(javaPbSource.getCtype)) else None,
    packed = if (javaPbSource.hasPacked) Some(javaPbSource.getPacked.booleanValue) else None,
    jstype = if (javaPbSource.hasJstype) Some(com.google.protobuf.descriptor.FieldOptions.JSType.fromJavaValue(javaPbSource.getJstype)) else None,
    `lazy` = if (javaPbSource.hasLazy) Some(javaPbSource.getLazy.booleanValue) else None,
    deprecated = if (javaPbSource.hasDeprecated) Some(javaPbSource.getDeprecated.booleanValue) else None,
    weak = if (javaPbSource.hasWeak) Some(javaPbSource.getWeak.booleanValue) else None,
    uninterpretedOption = javaPbSource.getUninterpretedOptionList.asScala.map(com.google.protobuf.descriptor.UninterpretedOption.fromJavaProto(_))
  )
  def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[_root_.com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): com.google.protobuf.descriptor.FieldOptions = {
    require(__fieldsMap.keys.forall(_.getContainingType() == javaDescriptor), "FieldDescriptor does not match message type.")
    val __fields = javaDescriptor.getFields
    com.google.protobuf.descriptor.FieldOptions(
      __fieldsMap.get(__fields.get(0)).asInstanceOf[scala.Option[_root_.com.google.protobuf.Descriptors.EnumValueDescriptor]].map(__e => com.google.protobuf.descriptor.FieldOptions.CType.fromValue(__e.getNumber)),
      __fieldsMap.get(__fields.get(1)).asInstanceOf[scala.Option[Boolean]],
      __fieldsMap.get(__fields.get(2)).asInstanceOf[scala.Option[_root_.com.google.protobuf.Descriptors.EnumValueDescriptor]].map(__e => com.google.protobuf.descriptor.FieldOptions.JSType.fromValue(__e.getNumber)),
      __fieldsMap.get(__fields.get(3)).asInstanceOf[scala.Option[Boolean]],
      __fieldsMap.get(__fields.get(4)).asInstanceOf[scala.Option[Boolean]],
      __fieldsMap.get(__fields.get(5)).asInstanceOf[scala.Option[Boolean]],
      __fieldsMap.getOrElse(__fields.get(6), Nil).asInstanceOf[scala.collection.Seq[com.google.protobuf.descriptor.UninterpretedOption]]
    )
  }
  def javaDescriptor: _root_.com.google.protobuf.Descriptors.Descriptor = DescriptorProtoCompanion.javaDescriptor.getMessageTypes.get(11)
  def messageCompanionForField(__field: _root_.com.google.protobuf.Descriptors.FieldDescriptor): _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
    require(__field.getContainingType() == javaDescriptor, "FieldDescriptor does not match message type.")
    var __out: _root_.com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
    __field.getNumber match {
      case 999 => __out = com.google.protobuf.descriptor.UninterpretedOption
    }
  __out
  }
  def enumCompanionForField(__field: _root_.com.google.protobuf.Descriptors.FieldDescriptor): _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[_] = {
    require(__field.getContainingType() == javaDescriptor, "FieldDescriptor does not match message type.")
    __field.getNumber match {
      case 1 => com.google.protobuf.descriptor.FieldOptions.CType
      case 6 => com.google.protobuf.descriptor.FieldOptions.JSType
    }
  }
  lazy val defaultInstance = com.google.protobuf.descriptor.FieldOptions(
  )
  sealed trait CType extends _root_.com.trueaccord.scalapb.GeneratedEnum {
    type EnumType = CType
    def isString: Boolean = false
    def isCord: Boolean = false
    def isStringPiece: Boolean = false
    def isUnrecognized: Boolean = false
    def companion: _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[CType] = CType
  }
  
  object CType extends _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[CType] {
    implicit def enumCompanion: _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[CType] = this
    @SerialVersionUID(0L)
    case object STRING extends CType {
      val value = 0
      val index = 0
      val name = "STRING"
      override def isString: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object CORD extends CType {
      val value = 1
      val index = 1
      val name = "CORD"
      override def isCord: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object STRING_PIECE extends CType {
      val value = 2
      val index = 2
      val name = "STRING_PIECE"
      override def isStringPiece: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case class Unrecognized(value: Int) extends CType {
      val name = "UNRECOGNIZED"
      val index = -1
      override def isUnrecognized: Boolean = true
    }
    
    lazy val values = scala.collection.Seq(STRING, CORD, STRING_PIECE)
    def fromValue(value: Int): CType = value match {
      case 0 => STRING
      case 1 => CORD
      case 2 => STRING_PIECE
      case __other => Unrecognized(__other)
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.EnumDescriptor = com.google.protobuf.descriptor.FieldOptions.javaDescriptor.getEnumTypes.get(0)
    def fromJavaValue(pbJavaSource: com.google.protobuf.DescriptorProtos.FieldOptions.CType): CType = fromValue(pbJavaSource.getNumber)
    def toJavaValue(pbScalaSource: CType): com.google.protobuf.DescriptorProtos.FieldOptions.CType = com.google.protobuf.DescriptorProtos.FieldOptions.CType.forNumber(pbScalaSource.value)
  }
  sealed trait JSType extends _root_.com.trueaccord.scalapb.GeneratedEnum {
    type EnumType = JSType
    def isJsNormal: Boolean = false
    def isJsString: Boolean = false
    def isJsNumber: Boolean = false
    def isUnrecognized: Boolean = false
    def companion: _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[JSType] = JSType
  }
  
  object JSType extends _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[JSType] {
    implicit def enumCompanion: _root_.com.trueaccord.scalapb.GeneratedEnumCompanion[JSType] = this
    @SerialVersionUID(0L)
    case object JS_NORMAL extends JSType {
      val value = 0
      val index = 0
      val name = "JS_NORMAL"
      override def isJsNormal: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object JS_STRING extends JSType {
      val value = 1
      val index = 1
      val name = "JS_STRING"
      override def isJsString: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case object JS_NUMBER extends JSType {
      val value = 2
      val index = 2
      val name = "JS_NUMBER"
      override def isJsNumber: Boolean = true
    }
    
    @SerialVersionUID(0L)
    case class Unrecognized(value: Int) extends JSType {
      val name = "UNRECOGNIZED"
      val index = -1
      override def isUnrecognized: Boolean = true
    }
    
    lazy val values = scala.collection.Seq(JS_NORMAL, JS_STRING, JS_NUMBER)
    def fromValue(value: Int): JSType = value match {
      case 0 => JS_NORMAL
      case 1 => JS_STRING
      case 2 => JS_NUMBER
      case __other => Unrecognized(__other)
    }
    def javaDescriptor: _root_.com.google.protobuf.Descriptors.EnumDescriptor = com.google.protobuf.descriptor.FieldOptions.javaDescriptor.getEnumTypes.get(1)
    def fromJavaValue(pbJavaSource: com.google.protobuf.DescriptorProtos.FieldOptions.JSType): JSType = fromValue(pbJavaSource.getNumber)
    def toJavaValue(pbScalaSource: JSType): com.google.protobuf.DescriptorProtos.FieldOptions.JSType = com.google.protobuf.DescriptorProtos.FieldOptions.JSType.forNumber(pbScalaSource.value)
  }
  implicit class FieldOptionsLens[UpperPB](_l: _root_.com.trueaccord.lenses.Lens[UpperPB, com.google.protobuf.descriptor.FieldOptions]) extends _root_.com.trueaccord.lenses.ObjectLens[UpperPB, com.google.protobuf.descriptor.FieldOptions](_l) {
    def ctype: _root_.com.trueaccord.lenses.Lens[UpperPB, com.google.protobuf.descriptor.FieldOptions.CType] = field(_.getCtype)((c_, f_) => c_.copy(ctype = Some(f_)))
    def optionalCtype: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[com.google.protobuf.descriptor.FieldOptions.CType]] = field(_.ctype)((c_, f_) => c_.copy(ctype = f_))
    def packed: _root_.com.trueaccord.lenses.Lens[UpperPB, Boolean] = field(_.getPacked)((c_, f_) => c_.copy(packed = Some(f_)))
    def optionalPacked: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Boolean]] = field(_.packed)((c_, f_) => c_.copy(packed = f_))
    def jstype: _root_.com.trueaccord.lenses.Lens[UpperPB, com.google.protobuf.descriptor.FieldOptions.JSType] = field(_.getJstype)((c_, f_) => c_.copy(jstype = Some(f_)))
    def optionalJstype: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[com.google.protobuf.descriptor.FieldOptions.JSType]] = field(_.jstype)((c_, f_) => c_.copy(jstype = f_))
    def `lazy`: _root_.com.trueaccord.lenses.Lens[UpperPB, Boolean] = field(_.getLazy)((c_, f_) => c_.copy(`lazy` = Some(f_)))
    def optionalLazy: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Boolean]] = field(_.`lazy`)((c_, f_) => c_.copy(`lazy` = f_))
    def deprecated: _root_.com.trueaccord.lenses.Lens[UpperPB, Boolean] = field(_.getDeprecated)((c_, f_) => c_.copy(deprecated = Some(f_)))
    def optionalDeprecated: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Boolean]] = field(_.deprecated)((c_, f_) => c_.copy(deprecated = f_))
    def weak: _root_.com.trueaccord.lenses.Lens[UpperPB, Boolean] = field(_.getWeak)((c_, f_) => c_.copy(weak = Some(f_)))
    def optionalWeak: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.Option[Boolean]] = field(_.weak)((c_, f_) => c_.copy(weak = f_))
    def uninterpretedOption: _root_.com.trueaccord.lenses.Lens[UpperPB, scala.collection.Seq[com.google.protobuf.descriptor.UninterpretedOption]] = field(_.uninterpretedOption)((c_, f_) => c_.copy(uninterpretedOption = f_))
  }
  final val CTYPE_FIELD_NUMBER = 1
  final val PACKED_FIELD_NUMBER = 2
  final val JSTYPE_FIELD_NUMBER = 6
  final val LAZY_FIELD_NUMBER = 5
  final val DEPRECATED_FIELD_NUMBER = 3
  final val WEAK_FIELD_NUMBER = 10
  final val UNINTERPRETED_OPTION_FIELD_NUMBER = 999
}
